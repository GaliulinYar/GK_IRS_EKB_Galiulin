Тестовое задание:

Написать очень простую django-подобную ORM модель на python.
Спроектировать архитектуру решения так, чтобы в дальнейшем его можно было легко расширять (например, использовать различные базы данных, добавлять новые типы полей).
Использовать сторонние библиотеки, реализующие ORM-модели нельзя.

Пример использования:

class SomeTable(OrmModel):
    pk = OrmInteger(primary_key=True)
    some_field_1 = OrmText()
    some_field_2 = OrmInteger()
    some_field_3 = OrmFloat()

Данный код (без какого-либо дополнительного), при запуске, должен создать sqlite базу данных и в ней таблицу SomeTable с колонками pk, some_field_1, some_field_2, some_field_3 соответствующих типов (если база данных и таблица еще не существуют).
Если пользователь (тот, кто унаследовался от класса OrmModel) не указал ни в одной из колонок primary_key=True, то автоматически должна создаться колонка (например с именем id), которая будет первичным ключом с автоинкрементом.
Соответственно, нужно написать классы OrmModel, OrmText, OrmInteger и OrmFloat.

Должна быть возможность добавлять записи в таблицу, соответствующую классу.
Должна быть возможность получить из наследников OrmModel следующие данные:
Все записи таблицы, например, генератор кортежей (в данном случае, кортежи будут вида (pk, some_field_1, some_field_2, some_field_3))
Записи, отфильтрованные по условию равенства. В качестве примера интерфейса можно взять filter из django, там это выглядит так: SomeTable.objects.filter(some_field_1__exact=='some_value')

Вместо наследования можно рассмотреть вариант декорирования класса.

Данный пример не нужно принимать как данность, можно реализовать по-своему, главное чтобы присутствовал описанная выше функциональность, а именно:
1) Создание sqlite БД, если она еще не существует;
2) Создание таблицы в БД (имя таблицы должно соответствовать имени класса, который эту таблицу представляет), если она еще не существует;
3) Таблица должна быть с полями, имена которых соответствуют именам членов класса;
4) Модель должна поддерживать поля типов TEXT, INTEGER и REAL;
5) Если в таблице нет члена класса с параметром primary_key=True, то первая колонка должна быть автоматически сгенерирована с первичным ключом и автоинкрементом;
6) У класса, представляющего таблицу, должен быть интерфейс, позволяющий добавить записи в таблицу.
7) У класса, представляющего таблицу, должен быть интерфейс, позволяющий получить все записи таблицы, а также записи, соответствующие фильтру равенства.